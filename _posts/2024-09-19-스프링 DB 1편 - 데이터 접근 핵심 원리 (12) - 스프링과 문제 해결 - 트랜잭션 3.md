---
title: 스프링 DB 1편 - 데이터 접근 핵심 원리 (12) - 스프링과 문제 해결 - 트랜잭션 3
aliases: 
tags:
  - spring
  - DB
  - transaction
categories:
  - spring
toc: true
toc_label: 목차
date: 2024-09-19
last_modified_at: 2024-09-19
---
>  인프런 스프링 DB 1편 - 데이터 접근 핵심 원리편을 학습하고 정리한 내용 입니다.

- [스프링과 문제 해결 - 트랜잭션 1](https://iamminseongkim.github.io/spring/%EC%8A%A4%ED%94%84%EB%A7%81-DB-1%ED%8E%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%91%EA%B7%BC-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-(10)-%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-1/)
- [스프링과 문제 해결 - 트랜잭션 2](https://iamminseongkim.github.io/spring/%EC%8A%A4%ED%94%84%EB%A7%81-DB-1%ED%8E%B8-%EB%8D%B0%EC%9D%B4%ED%84%B0-%EC%A0%91%EA%B7%BC-%ED%95%B5%EC%8B%AC-%EC%9B%90%EB%A6%AC-(11)-%EC%8A%A4%ED%94%84%EB%A7%81%EA%B3%BC-%EB%AC%B8%EC%A0%9C-%ED%95%B4%EA%B2%B0-%ED%8A%B8%EB%9E%9C%EC%9E%AD%EC%85%98-2/)


## 트랜잭션 문제 해결 - 트랜잭션 AOP 이해

지금까지 트랜잭션을 편리하게 처리하기 위해서 트랜잭션 추상화도 도입하고, 추가로 반복적인 트랜잭션 로직을 해결하기 위해 트랜잭션 템플릿도 도입했다.

트랜잭션 템플릿 덕분에 트랜잭션을 처리하는 반복 코드는 해결할 수 있었다. 하지만 **서비스 계층**에 **순수한 비즈니스 로직**만 남긴다는 목표는 아직 달성하지 못했다.

이럴 때 **스프링 AOP**를 통해 프록시를 도입하면 문제를 깔끔하게 해결할 수 있다.


### 프록시를 통한 문제 해결

![](https://i.imgur.com/XyCVuaC.png){: .align-center}


프록시를 도입하기 전에는 기존처럼 서비스의 로직에서 트랜잭션을 직접 시작한다.

```java
public void accountTransfer(String fromId, String toId, int money) throws SQLException {  
  
    // 트랜잭션 템플릿  
    txTemplate.executeWithoutResult((status) -> {  
        try {  
            // 비즈니스 로직  
            bizLogic(fromId, toId, money);  
        } catch (SQLException e) {  
            throw new IllegalStateException(e);  
        }  
    });  
}
```


![](https://i.imgur.com/jvEfAMx.png){: .align-center}


프록시를 사용하면 트랜잭션을 처리하는 객체와 비즈니스 로직을 처리하는 서비스 객체를 명확하게 분리할 수 있다.

**트랜잭션 프록시 코드 예시**
```java
public class TransactionProxy {  
    private MemberService target;  
    public void logic() {  
        //트랜잭션 시작  
        TransactionStatus status = transactionManager.getTransaction(..);  
        try {  
            //실제 대상 호출  
            target.logic();  
            transactionManager.commit(status); //성공시 커밋  
        } catch (Exception e) {  
            transactionManager.rollback(status); //실패시 롤백  
            throw new IllegalStateException(e);  
        }  
    }  
}
```


**트랜잭션 프록시 적용 후 서비스 코드 예시** 
```java
public class Service {  
    public void logic() {  
        //트랜잭션 관련 코드 제거, 순수 비즈니스 로직만 남음  
        bizLogic(fromId, toId, money);  
    }  
}
```

- 프록시 도입 전: 서비스에 비즈니스 로직과 트랜잭션 처리 로직이 함께 섞여있다.
- 프록시 도입 후: 트랜잭션 프록시가 트랜잭션 처리 로직을 모두 가져간다. 그리고 트랜잭션을 시작한 후에 실제 서비스를 대신 호출한다. 트랜잭션 프록시 덕분에 서비스 계층에는 순수한 비즈니즈 로직만 남길 수 있다.


### 스프링이 제공하는 트랜잭션 AOP

- 스프링이 제공하는 AOP 기능을 사용하면 프록시를 매우 편리하게 적용할 수 있다.
- 물론 스프링 AOP를 직접 사용해서 트랜잭션을 처리해도 되지만, 트랜잭션은 매우 중요한 기능이고, 전세계 누구나 다 사용하는 기능이다. 스프링은 트랜잭션 AOP를 처리하기 위한 모든 기능을 제공한다. 스프링 부트를 사용하면 트랜잭션 AOP를 처리하기 위해 필요한 스프링 빈들도 자동으로 등록해준다.
- 개발자는 트랜잭션 처리가 필요한 곳에 `@Transactional`애노테이션만 붙여주면 된다. 스프링의 트랜잭션 AOP는 이 애노테이션을 인식해서 트랜잭션 프록시를 적용해준다.

### @Transactional

`org.springframework.transaction.annotation.Transactional`

> **참고**<br>스프링 AOP를 적용하려면 어드바이저, 포인트컷, 어드바이스가 필요하다. 스프링은 트랜잭션 AOP 처리를 위해 다음 클래스를 제공한다. 스프링 부트를 사용하면 해당 빈들은 스프링 컨테이너에 자동으로 등록된다.<br><br>어드바이저: `BeanFactoryTransactionAttributeSourceAdvisor`<br>포인트컷: `TransactionAttributeSourcePointcut`<br>어드바이스: `TransactionInterceptor`


## 트랜잭션 문제 해결 - 트랜잭션 AOP 적용


트랜잭션 AOP를 사용하는 새로운 서비스 클래스를 만들자.

### MemberServiceV3_3
```java
/**  
 * 트랜잭션 - @Transactional AOP  
 */@Slf4j  
public class MemberServiceV3_3 {  
  
    private final MemberRepositoryV3 memberRepository;  
  
    public MemberServiceV3_3(MemberRepositoryV3 memberRepository) {  
        this.memberRepository = memberRepository;  
    }  
  
    @Transactional  
    public void accountTransfer(String fromId, String toId, int money) throws SQLException {  
        bizLogic(fromId, toId, money);  
    }  
  
    private void bizLogic(String fromId, String toId, int money) throws SQLException {  
        Member fromMember = memberRepository.findById(fromId);  
        Member toMember = memberRepository.findById(toId);  
  
        memberRepository.update(fromId, fromMember.getMoney() - money);  
        // 오류 케이스  
        validation(toMember);  
        memberRepository.update(toId, toMember.getMoney() + money);  
    }  
  
  
    private void validation(Member toMember) {  
        if (toMember.getMemberId().equals("ex"))  
            throw new IllegalStateException("이체중 예외 발생");  
    }  
}
```

- 순수한 비즈니스 로직만 남기고, 트랜잭션 관련 코드는 모두 제거했다.
- 스프링이 제공하는 트랜잭션 AOP를 적용하기 위해 `@Transactional`애노테이션을 추가했다.
- `@Transactional` 애노테이션은 메서드에 붙여도 되고, 클래스에 붙여도 된다. 클래스에 붙이면 외부에서 호출 가능한 `public`메서드가 AOP 적용 대상이 된다.

이제 진짜 트랜잭션 되는지 테스트 해보자.

### MemberServiceV3_3Test

```java
/**  
 * 트랜잭션 - @Transactional AOP  
 */class MemberServiceV3_3Test {  
  
    public static final String MEMBER_A = "memberA";  
    public static final String MEMBER_B = "memberB";  
    public static final String MEMBER_EX = "ex";  
  
    private MemberRepositoryV3 memberRepository;  
    private MemberServiceV3_3 memberService;  
  
    @BeforeEach  
    void before() {  
        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);  
        memberRepository = new MemberRepositoryV3(dataSource);  
  
        memberService = new MemberServiceV3_3(memberRepository);  
    }  
  
    @AfterEach  
    void after() throws SQLException {  
        memberRepository.delete(MEMBER_A);  
        memberRepository.delete(MEMBER_B);  
        memberRepository.delete(MEMBER_EX);  
    }  
  
    @Test  
    @DisplayName("정상 이체")  
    void accountTransfer() throws SQLException {  
        //given  
        Member memberA = new Member(MEMBER_A, 10000);  
        Member memberB = new Member(MEMBER_B, 10000);  
  
        memberRepository.save(memberA);  
        memberRepository.save(memberB);  
  
        //when  
        memberService.accountTransfer(memberA.getMemberId(), memberB.getMemberId(), 2000);  
        //then  
        Member findMemberA = memberRepository.findById(memberA.getMemberId());  
        Member findMemberB = memberRepository.findById(memberB.getMemberId());  
  
        assertThat(findMemberA.getMoney()).isEqualTo(8000);  
        assertThat(findMemberB.getMoney()).isEqualTo(12000);  
  
    }  
  
    @Test  
    @DisplayName("이체중 예외 발생")  
    void accountTransferEx() throws SQLException {  
        //given  
        Member memberA = new Member(MEMBER_A, 10000);  
        Member memberEx = new Member(MEMBER_EX, 10000);  
  
        memberRepository.save(memberA);  
        memberRepository.save(memberEx);  
  
        //when  
        assertThatThrownBy(() ->  
                memberService.accountTransfer(memberA.getMemberId(), memberEx.getMemberId(), 2000))  
                .isInstanceOf(IllegalStateException.class);  
  
        //then  
        Member findMemberA = memberRepository.findById(memberA.getMemberId());  
        Member findMemberEx = memberRepository.findById(memberEx.getMemberId());  
  
        assertThat(findMemberA.getMoney()).isEqualTo(10000); // 트랜잭션 처리했기때문에 이제 10000원 정상  
        assertThat(findMemberEx.getMoney()).isEqualTo(10000);  
    }  
}
```

자 v3_3를 받아서 기존 테스트와 동일하게 사용했다.

이제 테스트를 돌려보면..

![](https://i.imgur.com/fxQrPBS.png){: .align-center}

예외가 발생한다. 롤백이 일어나지 않았다.

이유는 간단하다. 이 테스트 코드는 스프링 테스트 코드가 아니기 때문이다.

```java
@SpringBootTest  
class MemberServiceV3_3Test {
  
    public static final String MEMBER_A = "memberA";  
    public static final String MEMBER_B = "memberB";  
    public static final String MEMBER_EX = "ex";  
  
    @Autowired  
    private MemberRepositoryV3 memberRepository;  
    @Autowired  
    private MemberServiceV3_3 memberService;  
  
    @TestConfiguration  
    static class testConfig {  
        @Bean  
        DataSource dataSource() {  
            return new DriverManagerDataSource(URL, USERNAME, PASSWORD);  
        }  
  
        @Bean  
        PlatformTransactionManager transactionManager() {  
            return new DataSourceTransactionManager(dataSource());  
        }  
  
        @Bean  
        MemberRepositoryV3 memberRepository() {  
            return new MemberRepositoryV3(dataSource());  
        }  
  
        @Bean  
        MemberServiceV3_3 memberService() {  
            return new MemberServiceV3_3(memberRepository());  
        }  
    }  
  
//    @BeforeEach  
//    void before() {  
//        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);  
//        memberRepository = new MemberRepositoryV3(dataSource);  
//  
//        memberService = new MemberServiceV3_3(memberRepository);  
//    }

... 
}
```

다음과 같이 `bean`들을 만들어 줘야 하고(서비스 코드에 `@Service` 이런거 안달았다.)

`@Autowired`로 의존성 주입 받았다.

- `@SpringBootTest` : 스프링 AOP를 적용하려면 스프링 컨테이너가 필요하다. 이 애노테이션이 있으면 테스트시 스프링 부트를 통해 스프링 컨테이너를 생성한다. 그리고 테스트에서 `@Autowired`등을 통해 스프링 컨테이너가 관리하는 빈들을 사용할 수 있다.
- `@TestConfiguration` : 테스트 안에서 내부 설정 클래스를 만들어서 사용하면서 이 에노테이션을 붙이면, 스프링 부트가 자동으로 만들어주는 빈들에 추가로 필요한 스프링 빈들을 등록하고 테스트를 수행할 수 있다.
- `TestConfig`
	- `DataSource` 스프링에서 기본으로 사용할 데이터소스를 스프링 빈으로 등록한다. 추가로 트랜잭션 매니저에서도 사용한다.
	- `DataSourceTransactionManager` 트랜잭션 매니저를 스프링 빈으로 등록한다.
		- 스프링이 제공하는 트랜잭션 AOP는 스프링 빈에 등록된 트랜잭션 매니저를 찾아서 사용하기 때문에 트랜잭션 매니저를 스프링 빈으로 등록해두어야 한다.

![](https://i.imgur.com/uOHtbzq.png){: .align-center}

이제 예외가 발생하지 않고 정상적으로 트랜잭션이 작동한 걸 확인할 수 있다.


#### AOP 프록시 적용 확인 

```java
@Test  
void AopCheck() {  
    log.info("memberService class={}", memberService.getClass());  
    log.info("memberRepository class={}", memberRepository.getClass());  
    Assertions.assertThat(AopUtils.isAopProxy(memberService)).isTrue();  
    Assertions.assertThat(AopUtils.isAopProxy(memberRepository)).isFalse();  
}
```

![](https://i.imgur.com/wzhuvC6.png){: .align-center}

서비스는 다음과 같이 CGLIB를 사용해서 프록시가 적용된 걸 확인할 수 있다. (`@Transactional`)

리포지토리단은 따로 뭐 사용한게 없기 때문에 순수 구체가 출력된다.



